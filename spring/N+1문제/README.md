# JPA N+1 문제 해결하기

## 1. N+1 문제란 무엇인가?

N+1 문제란? 연관관계가 설정된 데이터를 조회할때 방생하는 문제입니다.  
데이터가 `유저-게시글`의 연관관계를 가지고 있다고 생각해보겠습니다.  

유저 데이터를 조회하는 요청이 왔을때 유저 데이터를 우선적으로 조회하게 됩니다.   
또한 유저와 연관관계를 가지고 있는 게시글 역시 조회 하게 됩니다.  
N+1 문제는 이때 조회의 대상이 되는 데이터(게시글)의 연관관계 데이터를 모두 조회 하며 발생하게 됩니다.  
즉, 유저 100명을 조회하였는데, 연관관계인 게시글은 조회를 하지 않았으니, 유저마다 가지고 있는 게시글을 전부 조회해야 합니다.  
이때 유저 100명을 조회하는 쿼리는 1이며, 유저들의 게시글을 조회를 쿼리가 최대 100번만큼 발생합니다. 이를 N이라고 합니다.  
N+1 문제는 데이터 조회하는 쿼리(1)의 데이터의 갯수 N 만큼 연관관계의 조회 쿼리가 추가로 발생하는 문제입니다.     
어떤분들은 1+N 문제라고 말씀하시는 분들도 있는데 동일한 의미입니다.  

그럼 이게 왜 문제가 되는지 아직 감이 안오시는분들이 있을수도 있습니다.   
데이터를 조회하는 쿼리에서 결과가가 1~2개인 경우 10개의 추가 쿼리가 발생하게 됩니다.   
아직까지는 괜찮다고 볼수도 있습니다. 총 2개~4개의 쿼리가 발생할테니까요.   
하지만 조회한 데이터의 결과가 1만개인 경우는 어떨까요?   
네 하나의 조회 요청에 1+1만개 만큼의 쿼리가 발생하게 됩니다.  
이러한 조회 요청이 수시로 들어오게 되면, 결국 데이터 베이스는 부하를 감당하지 못하게 됩니다.  
클라우드 환경에서는 리소스를 엄청나게 사용하게되어 의도하지 않은 엄청난 과금을 맛볼수 있습니다.  

우린 N+1 문제가 무엇인지 알아봤습니다.
그럼 좀 더 쉽게 알아보기 위해서 두개의 테이블과 코드를 가지고 설명을 하도록 하겠습니다.  
설명에 사용할 테이블은 사용자 테이블과 팀 테이블 2개입니다.   

사용자(User) 테이블

| User ||
|:----:|:----:|
| id   | Long   |
| name | String | 
| post | List\<post\>   |

게시글(Post) 테이블

| Post ||
|:----:|:----:|
| id   | Long   |
| name | String | 
| users | User  |

사용자는 여러개의 게시글을 가질수 있지만, 게시글은 한명의 사용자만을 가질수 있습니다.  

| 유저 | 게시글들 |
|:-----:|:-----:|
| 사람1 | 글1, 글2, 글3, 글4, ... |

게시글과 사용자는 `@ManyToOne` 연관관계를 가진다.   
사용자와 게시글은 `@OneToMany` 연관관게를 가진다.  

테이블을 클래스로 나타내면 다음과 같습니다.  

```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private long id;

    @OneToMany(fetch = FetchType.EAGER) // 즉시 로딩
    private List<Post> posts = new ArrayList<>();
}
```

```java
@Entity
public class Post {
    @Id
    @GeneratedValue
    private long id;

    @ManyToOne(fetch = FetchType.EAGER) // 즉시 로딩
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}
```

연관관계의 fetch 타입을 지연 로딩으로 설정 해줍니다.  
예제에서는 N+1을 발생시켜야 하므로 즉시로딩을 사용하도록 합니다.  

지연 로딩/즉시 로딩의 차이에 대해 알아보도록 하겠습니다.  
즉시 로딩의 경우 데이터를 조회할때 연관된 데이터까지 한번에 불러오는 방법입니다.  
유저 데이터를 조회하는 경우 게시글까지 `즉시` 조회하는 방식 입니다.  

지연 로딩은 데이터 조회시 연관된 데이터를 `즉시` 조회하지 않고, 나중에(`지연`) 가져오는 방식 입니다.  
유저 데이터를 조회하는 경우, 유저 데이터를 조회를 해서 가져옵니다.  
하지만 게시글 데이터는 바로 가져오지 않고, 연관 데이터에 프록시 객체(임시객체)를 생성후 설정해놓습니다.  
그리고 연관된 데이터를 참조하는 시점(실제 사용 시점)에 객체를 가져오는 방법입니다.   
연관관계로 맺어진 데이터를 바로 사용하는 경우가 아니라면, 임시 객체를 넣어 놓고 실제 사용하는 경우에 조회해 오는 방식입니다.  

전체 유저를 조회해보기 전에, N+1 문제를 눈으로 확인하기 위해 설정 하나를 추가해주도록 해보겠습니다.  
실제 구동되는 쿼리를 눈으로 보기 위해서 `application.yaml` 파일에 아래 내용을 추가해줍니다.  

```yaml
spring:
  jpa:
    properties:
      hibernate:
        show_sql: true    # 수행되는 SQL문을 보여준다.
        format_sql: true  # 수행되는 SQL을 보기 쉽게 출력해준다.
```

이제 전체 유저를 조회해봅니다.  

```java
userRepository.findAll();
```

이제 실제 수행된 쿼리문을 확인해보자.  

```sql

```
(수정 필요)
우리는 여기서 무언가 이상함을 눈치챌 수 있습니다.   
실제로 유저를 조회하는 쿼리 1개만 나갈것으로 예상했지만, 다수의 쿼리가 나간것을 확인할수 있습니다.  
각각의 팀은 팀원을 가지고있고, 팀을 조회하는 경우 팀에 소속된 팀원의 정보를 가져와야 합니다.  
팀이 10개면 각각의 팀의 팀원을 조회하는 쿼리가 1개씩 총 10번의 쿼리가 발생하게됩니다.  
N+1 문제는 N과 1이 의미하는 바는 바로 다음과 같습니다.   
N (팀에 소속된 팀원을 조회하는 쿼리) +(추가로 발생) 1 (팀전체를 조회하는 쿼리)

```java
@OneToMany(fetch = FetchType.EAGER)
```

그럼 무엇이 문제였을까요? 즉시 로딩이 문제였을까요?
한번 즉시 로딩을 지연 로딩으로 변경해보겠습니다

```java
@OneToMany(fetch = FetchType.LAZY)
```

또다시 전체 팀원을 조회해보겠습니다.  

```java
List<Team> teams = teamRepository.findAll();
```

언뜻 보면 크게 문제가 없어보입니다.  
이것이 더 큰 문제입니다. 왜 더 큰문제인지는 생각을 좀 더 해보겠습니다.   
우리는 지연로딩을 사용했습니다. 지연로딩은 연관된 데이터(소속된 팀원)를 참조하기 전까지는 쿼리가 수행되지 않습니다.  
위의 조회에서는 연관된 데이터를 참조하지 않았습니다.   
즉, 로딩되는 시점의 코드를 사용하지 않아서, 언뜻보면 N+1 문제가 해결된 것처럼 보이는 것입니다.  
실제 N+1 문제가 해결되었는지 확인하기 위해서 연관된 데이터 사용하는 코드를 추가해보겠습니다.   

```java
team.getUsers.forEach(user -> {
    System.out.Println(user.getTeam.getName() + " : " + user->getName());
});
```

추가할 코드는 조회한 팀의 소속된 팀원의 이름을 전부 출력하는 코드입니다.  
코드의 실행 결과는 팀별로 팀원의 이름을 출력하므로 따로 추가하지 않겠습니다.  
그럼 제일 중요한 실제 수행되는 쿼리문을 한번 보겠습니다.

```sql
```

역시 N+1 문제가 발생하합니다.  

