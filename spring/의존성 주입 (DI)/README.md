# 의존성 주입 (DI)

## 1. 의존성 주입(DI) 이란 무엇인가?

의존성 주입 (Dependency Injection)에 대해 알아보기 전에 객체지향 프로그래밍에 대해 알아보겠습니다.  
객체 지향 프로그래밍을 통해 애플리케이션을 만들때 다양한 객체를 생성하게 됩니다.  
생성된 객체들은 특정 기능을 수행하기 위해 서로 다른 객체들과 상호 작용(message passing)을 하게됩니다.  

좀더 쉽게 설명하기 위해 자동차, 휠, 타이어를 예로 들어보겠습니다.  
```
1. 자동차는 4개의 바퀴를 가지고 있고, 바퀴는 휠과 타이어로 구성되어있습니다.  
2. 경우에 따라 자동차의 휠과 타이어를 교체할 수 있습니다.  
```

위의 문장에 객체를 대입해서 생각해보겠습니다.  
```
1. 자동차 객체는 생산 과정에서 휠과 타이어를 필요로 합니다.
2. 자동차 객체는 다른 휠 객체와 타이어 객체로 교체가 가능합니다.
```

여기서 1번에 대해 자세히 보도록 하곘습니다. 자동차는 반드시 4개의 바퀴를 가지고 있습니다.  
바퀴 객체(휠 + 타이어)는 자동차 객체보다 먼저 생성될수 있지만, 자동차 객체는 생성 시점에는 바퀴 객체를 가지고 있어야 합니다.  
이것을 `의존성`이라고 합니다. 이때 자동차 객체는 바퀴 객체에 의존성을 가지고 있다고 합니다.  

자동차 생성시에 무조건 A 바퀴를 가져야 하는것은 아닙니다. A, B, C의 타이어가 있고 호환이 된다면 모두 가질 수 있습니다.  
그럼 자동차를 만드는 방법에 대해서 한번 생각 해보겠습니다.  
```
1. 자동차와 바퀴를 한번에 만드는 경우
2. 자동차를 만든후 바퀴를 조립하는 방식
```
1번 자동차와 바퀴를 모두 한번에 만드는 경우를 객체 지향의 상속이라고 생각 해보겠습니다.
```java
class Wheel {
    ...
};

class Car implements Wheel {
    ...
};
```
2번 자동차와 바퀴를 따로 만든후 조립하는 경우를 생각해보겠습니다.  
이때 두가지 방법이 있을것같습니다.  

(1) 자동차를 만들고 이후 바퀴를 만들어 조립하는 경우  
(2) 자동차와 바퀴를 따로 만든후 조립하는 경우  

얼핏보면 같은말 같지만, 좀더 생각을 해보면 바퀴를 만들고 조립하는 시점에 대한 차이가 있습니다.  
이해를 위해 (1)의 경우는 같은 공장에서 만든다고 생각을 하고, (2)의 경우는 서로다른 공장에서 만든다고 생각을 해보겠습니다.  

(1)를 코드로 옮겨 보겠습니다.
```java
class Wheel {
    ...
};

class Car {
    Wheel wheel;

    Car() {
        wheel = new Wheel();
    }
};
```
자동차와 바퀴를 같은 공장에서 만들고 있으므로, 자동차를 만들때 타이어를 만들어 조립하게 됩니다.  
자동차 객체를 만들때 바퀴 객체를 내부에서 만들어 조립 하고 있습니다.  

(2)의 경우를 코드로 옮겨보면 다음과 같습니다.
```java
class Wheel {
    ...
};

class Car {
    Wheel wheel

    Car(Wheel wheel) {
        this.wheel = wheel;
    }
};
```
자동차 공장과 바퀴 공장은 서로 다른 공장이므로, 자동차를 만들때 이미 만들어진 바퀴를 조립하게 됩니다.  
자동차 객체를 만들때 외부에서 만들어진 바퀴 객체를 조립 하고 있습니다.  

자동차와 바퀴를 조립하는 작업을 왜 이렇게 복잡하게 설명하냐 하실수도 있습니다.  
하지만 우리는 예시를 통해 이미 의존성 주입의 개념을 모두 학습하였습니다.  
무슨 소리인지 모르시겠다면 다시한번 살펴보겠습니다.  

`자동차와 바퀴를 서로 다른 공장에서 만들고, 자동차를 만들때 바퀴를 가져와 조립하는 방법`이 바로 의존성 주입 입니다.  

## 2. 의존성 주입(DI)을 사용하는 이유는?

그럼 의존성 주입을 왜 사용하는걸까요?  

위의 예제에서 바퀴는 한개만을 가지고 예시를 들었습니다.  
하지만 자동차가 한종류의 바퀴만 사용해야 하는걸까요?  
아닙니다. 자동차는 여러 종류의 바퀴를 장착해서 사용할수 있습니다.  

```java
class WheelA {
    ...
}

class WheelB {
    ...
}
```

다음과 같이 두종류의 바퀴가 있다고 생각해봅시다.  
자동차 객체에 두개의 바퀴를 선택해서 사용하려면 다음과 같이 해야할것입니다.  

```java
class Car {
    Wheel wheel;
    Car() {
        if() { // A바퀴를 사용하는 경우
            wheel = new WheelA();
        } else if() { // B바퀴를 사용하는 경우
            wheel = new WheelB();
        }
    }
}
```

아직은 2개의 바퀴만 사용중이지만, 바퀴가 10개로 늘어나고 100개로 늘어나게 되면 어떻게 될까요?  
if...else 구문을 반복해서 만들어줘야 할것입니다.  

또한 위의 예제들은 이해를 위해 많은 부분을 생략하였습니다.  
예제에서는 Wheel 과 WheelA, WheelB가 마치 같은 객체인것처럼 사용하였습니다.  
하지만 세개의 객체는 사실 서로 다른 객체 입니다.  
즉, wheel 이라는 객체에 WheelA의 객체를 대입할 수 없습니다.  

이를 해결하기 위해서 우리는 좀 더 생각을 해봐야 합니다.  
바퀴는 사실 동그란 구체 모양으로 실제로는 모양과 재질만 다르고, 바퀴의 본질은 변하지 않습니다.  
그럼 이런 공통적인 기본 특성을 반복적으로 구현하지 않는 방법은 없을까요?  
네, 바로 인터페이스를 이용하여 상속관계를 만들어주면 됩니다.  

Wheel이라는 객체를 인터페이스로 선언하고, 실제 바퀴들은 이 인터페이스를 상속받아 구현하는 방법을 사용하겠습니다.  

```java
interface Wheel {
    ...
}

class WheelA implements Wheel {
    ...
}

class WheelB implements Wheel {
    ...
}
```

바퀴 A, B 객체는 바퀴 프레임 인터페이스를 상속받아 구현되었습니다.  
그럼 이제 이 객체들을 통해 좀 더 유연한 방법으로 의존성을 주입하는 코드를 보도록하겠습니다.  

```java
class Car {
    Wheel wheel;

    Car(Wheel wheel) {
        this.wheel = wheel;
    }
}
```

어디서 많이본 코드가 아닌가요? 이전 내용을 한번 확인해봅시다.  
의존성 주입이란 무엇인가?의 예제의 (2)번에서 이미 봤던 코드입니다.  
하지만 (2)에서의 의미와는 다르게 Wheel은 인터페이스 입니다.  
생성자를 통해 Wheel 객체의 인스턴스를 인자로 받아 Car객체 내부에 주입하고 있습니다.  
이전 예제에서 처럼 if...else 구문없이 원하는 종류의 타이어 객체를 주입할수 있게 되었습니다.  

자동차와 바퀴의 관계로 설명을 하였지만, 의존성 주입을 사용해야 하는 이유를 좀더 알아볼까요?   
자동차 객체를 우리가 사용하는 백엔드 서버로 바꿔서 생각을 해보고, 바퀴를 데이터 베이스로 바꿔 생각해보겠습니다.  
우리가 어떠한 서비스를 만드는데, 저장소가 MySQL로 임시로 저장되었다고 가정해봅시다.  
근데 추후에는 다른 데이터 베이스를 사용할수도 있다고 합니다.  

의존성 주입을 사용하지 않고 개발을 하였고, 일정 시간이 지났다고 생각해봅시다.  
MySQL에 조회, 삽입, 수정, 삭제를 구현하였다고 생각해봅시다.  
그리고 데이터 베이스가 Postgresql로 변경되었고, 우리는 변경된 DB에 해당하는 코드를 사용해야 합니다.  
이때 변경된 것은 DB인데, 우리는 백엔드 서버의 코드를 변경해야 합니다.  

근데 만일 의존성 주입을 사용해서 DB 작업을 하는 인터페이스를 사용했다고 생각해봅시다.  
Postgresql 이던 Oracle이던 DB에 대한 코드, 즉 DB의 객체만 변경해주면 됩니다.  

## 3. 의존성 주입 방법

의존성 주입 방법에는 4가지가 있습니다.  
첫번째 방법은 위의 예제에서 사용한 생성자 주입방법이 있습니다.  
두번째 방법은 필드 주입 방법으로 @Autowired 어노테이션을 사용하는 방법이다.  
세번째 방법은 수정자(setter) 주입이다.  
마지막 네번째 방법은 메서드 주입이다.  
그럼 차례 대로 의존성 주입 방법에 대해 알아보겠습니다.  